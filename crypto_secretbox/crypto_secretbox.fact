// crypto_secretbox_MACBYTES = 16

// NOTE: the original function has an additional parameter
// `const unsigned char *c`, but the secretbox code passes
// NULL in for this parameter so I'm just not using it
// also I'm just hardcoding the `const int rounds` parameter
// since in secretbox it's always 20
void _crypto_core_salsa20( // crypto_core_salsa in core_salsa_ref.c
    secret mut uint8[64] out,
    secret uint8[16] in,
    secret uint8[32] k) {
  secret mut uint32 x0 = 0x61707865;
  secret mut uint32 x5 = 0x3320646e;
  secret mut uint32 x10 = 0x79622d32;
  secret mut uint32 x15 = 0x6b206574;

  secret uint32 j0 = x0;
  secret uint32 j5 = x5;
  secret uint32 j10 = x10;
  secret uint32 j15 = x15;

  secret mut uint32 x1 = _load_le(arrview(k, 0, 4));
  secret mut uint32 x2 = _load_le(arrview(k, 4, 4));
  secret mut uint32 x3 = _load_le(arrview(k, 8, 4));
  secret mut uint32 x4 = _load_le(arrview(k, 12, 4));
  secret mut uint32 x11 = _load_le(arrview(k, 16, 4));
  secret mut uint32 x12 = _load_le(arrview(k, 20, 4));
  secret mut uint32 x13 = _load_le(arrview(k, 24, 4));
  secret mut uint32 x14 = _load_le(arrview(k, 28, 4));

  secret uint32 j1 = x1;
  secret uint32 j2 = x2;
  secret uint32 j3 = x3;
  secret uint32 j4 = x4;
  secret uint32 j11 = x11;
  secret uint32 j12 = x12;
  secret uint32 j13 = x13;
  secret uint32 j14 = x14;

  secret mut uint32 x6 = _load_le(arrview(in, 0, 4));
  secret mut uint32 x7 = _load_le(arrview(in, 4, 4));
  secret mut uint32 x8 = _load_le(arrview(in, 8, 4));
  secret mut uint32 x9 = _load_le(arrview(in, 12, 4));

  secret uint32 j6 = x6;
  secret uint32 j7 = x7;
  secret uint32 j8 = x8;
  secret uint32 j9 = x9;

  for (uint32 i = 0 to 10) {
    x4  ^= (x0  + x12) <<<  7 ;
    x8  ^= (x4  + x0 ) <<<  9 ;
    x12 ^= (x8  + x4 ) <<<  13;
    x0  ^= (x12 + x8 ) <<<  18;
    x9  ^= (x5  + x1 ) <<<  7 ;
    x13 ^= (x9  + x5 ) <<<  9 ;
    x1  ^= (x13 + x9 ) <<<  13;
    x5  ^= (x1  + x13) <<<  18;
    x14 ^= (x10 + x6 ) <<<  7 ;
    x2  ^= (x14 + x10) <<<  9 ;
    x6  ^= (x2  + x14) <<<  13;
    x10 ^= (x6  + x2 ) <<<  18;
    x3  ^= (x15 + x11) <<<  7 ;
    x7  ^= (x3  + x15) <<<  9 ;
    x11 ^= (x7  + x3 ) <<<  13;
    x15 ^= (x11 + x7 ) <<<  18;
    x1  ^= (x0  + x3 ) <<<  7 ;
    x2  ^= (x1  + x0 ) <<<  9 ;
    x3  ^= (x2  + x1 ) <<<  13;
    x0  ^= (x3  + x2 ) <<<  18;
    x6  ^= (x5  + x4 ) <<<  7 ;
    x7  ^= (x6  + x5 ) <<<  9 ;
    x4  ^= (x7  + x6 ) <<<  13;
    x5  ^= (x4  + x7 ) <<<  18;
    x11 ^= (x10 + x9 ) <<<  7 ;
    x8  ^= (x11 + x10) <<<  9 ;
    x9  ^= (x8  + x11) <<<  13;
    x10 ^= (x9  + x8 ) <<<  18;
    x12 ^= (x15 + x14) <<<  7 ;
    x13 ^= (x12 + x15) <<<  9 ;
    x14 ^= (x13 + x12) <<<  13;
    x15 ^= (x14 + x13) <<<  18;
  }

  _store_le(ref arrview(out,  0, 4), x0  + j0 );
  _store_le(ref arrview(out,  4, 4), x1  + j1 );
  _store_le(ref arrview(out,  8, 4), x2  + j2 );
  _store_le(ref arrview(out, 12, 4), x3  + j3 );
  _store_le(ref arrview(out, 16, 4), x4  + j4 );
  _store_le(ref arrview(out, 20, 4), x5  + j5 );
  _store_le(ref arrview(out, 24, 4), x6  + j6 );
  _store_le(ref arrview(out, 28, 4), x7  + j7 );
  _store_le(ref arrview(out, 32, 4), x8  + j8 );
  _store_le(ref arrview(out, 36, 4), x9  + j9 );
  _store_le(ref arrview(out, 40, 4), x10 + j10);
  _store_le(ref arrview(out, 44, 4), x11 + j11);
  _store_le(ref arrview(out, 48, 4), x12 + j12);
  _store_le(ref arrview(out, 52, 4), x13 + j13);
  _store_le(ref arrview(out, 56, 4), x14 + j14);
  _store_le(ref arrview(out, 60, 4), x15 + j15);
}

// NOTE: the original function has an additional parameter
// `const unsigned char *c`, but the secretbox code passes
// NULL in for this parameter so I'm just not using it
export
void _crypto_core_hsalsa20(
    secret mut uint8[32] out,
    secret uint8[16] in,
    secret uint8[32] k) {
  secret mut uint32 x0 = 0x61707865;
  secret mut uint32 x5 = 0x3320646e;
  secret mut uint32 x10 = 0x79622d32;
  secret mut uint32 x15 = 0x6b206574;

  secret mut uint32 x1 = _load_le(arrview(k, 0, 4));
  secret mut uint32 x2 = _load_le(arrview(k, 4, 4));
  secret mut uint32 x3 = _load_le(arrview(k, 8, 4));
  secret mut uint32 x4 = _load_le(arrview(k, 12, 4));
  secret mut uint32 x11 = _load_le(arrview(k, 16, 4));
  secret mut uint32 x12 = _load_le(arrview(k, 20, 4));
  secret mut uint32 x13 = _load_le(arrview(k, 24, 4));
  secret mut uint32 x14 = _load_le(arrview(k, 28, 4));
  secret mut uint32 x6 = _load_le(arrview(in, 0, 4));
  secret mut uint32 x7 = _load_le(arrview(in, 4, 4));
  secret mut uint32 x8 = _load_le(arrview(in, 8, 4));
  secret mut uint32 x9 = _load_le(arrview(in, 12, 4));

  for (uint32 i = 0 to 10) {
    x4  ^= (x0  + x12) <<<  7 ;
    x8  ^= (x4  + x0 ) <<<  9 ;
    x12 ^= (x8  + x4 ) <<<  13;
    x0  ^= (x12 + x8 ) <<<  18;
    x9  ^= (x5  + x1 ) <<<  7 ;
    x13 ^= (x9  + x5 ) <<<  9 ;
    x1  ^= (x13 + x9 ) <<<  13;
    x5  ^= (x1  + x13) <<<  18;
    x14 ^= (x10 + x6 ) <<<  7 ;
    x2  ^= (x14 + x10) <<<  9 ;
    x6  ^= (x2  + x14) <<<  13;
    x10 ^= (x6  + x2 ) <<<  18;
    x3  ^= (x15 + x11) <<<  7 ;
    x7  ^= (x3  + x15) <<<  9 ;
    x11 ^= (x7  + x3 ) <<<  13;
    x15 ^= (x11 + x7 ) <<<  18;
    x1  ^= (x0  + x3 ) <<<  7 ;
    x2  ^= (x1  + x0 ) <<<  9 ;
    x3  ^= (x2  + x1 ) <<<  13;
    x0  ^= (x3  + x2 ) <<<  18;
    x6  ^= (x5  + x4 ) <<<  7 ;
    x7  ^= (x6  + x5 ) <<<  9 ;
    x4  ^= (x7  + x6 ) <<<  13;
    x5  ^= (x4  + x7 ) <<<  18;
    x11 ^= (x10 + x9 ) <<<  7 ;
    x8  ^= (x11 + x10) <<<  9 ;
    x9  ^= (x8  + x11) <<<  13;
    x10 ^= (x9  + x8 ) <<<  18;
    x12 ^= (x15 + x14) <<<  7 ;
    x13 ^= (x12 + x15) <<<  9 ;
    x14 ^= (x13 + x12) <<<  13;
    x15 ^= (x14 + x13) <<<  18;
  }

  _store_le(ref arrview(out, 0, 4), x0);
  _store_le(ref arrview(out, 4, 4), x5);
  _store_le(ref arrview(out, 8, 4), x10);
  _store_le(ref arrview(out, 12, 4), x15);
  _store_le(ref arrview(out, 16, 4), x6);
  _store_le(ref arrview(out, 20, 4), x7);
  _store_le(ref arrview(out, 24, 4), x8);
  _store_le(ref arrview(out, 28, 4), x9);
}

export
public int32 _crypto_stream_salsa20( // stream_ref in salsa20_ref.c
    secret mut uint8[] c,
    public uint8[8] n,
    secret uint8[32] k) {
  if (len c == 0) {
    return 0;
  }
  secret mut uint8[32] kcopy = arrcopy(k);
  secret mut uint8[16] in = arrzeros(16);
  for (uint32 i = 0 to 8) {
    in[i] = n[i];
  }
  // in[8..15] = 0 already taken care of by arrzeros
  public uint32 ctimes = len c >> 6;
  for (uint32 j = 0 to ctimes) {
    _crypto_core_salsa20(ref arrview(c, j*64, 64), in, kcopy);
    secret mut uint32 u = 1;
    for (uint32 i = 8 to 16) {
      u += in[i];
      in[i] = (uint8)u;
      u >>= 8;
    }
  }
  secret mut uint8[64] block = noinit(64);
  if (ctimes * 64 < len c) {
    _crypto_core_salsa20(ref block, in, kcopy);
    public uint32 remain = len c - ctimes * 64;
    secret mut uint8[] cview = arrview(c, ctimes*64, remain);
    for (uint32 i = 0 to remain) {
      cview[i] = block[i];
    }
  }
  _fact_memzero(ref block);
  _fact_memzero(ref kcopy);

  return 0;
}


export
public int32 _crypto_stream_salsa20_xor_ic( // stream_ref_xor_ic in salsa20_ref.c
    secret mut uint8[] c,
    secret uint8[] m,
    secret uint8[8] n,
    public uint64 ic_val,
    secret uint8[32] k) {
  if (len m == 0) {
    return 0;
  }
  public mut uint64 ic = ic_val;
  secret mut uint8[32] kcopy = arrcopy(k);
  secret mut uint8[16] in = arrzeros(16);
  for (uint32 i = 0 to 8) {
    in[i] = n[i];
  }
  for (uint32 i = 8 to 16) {
    in[i] = ic & (uint8)0xff;
    ic >>= 8;
  }
  public uint32 mtimes = len m >> 6;
  secret mut uint8[64] block = noinit(64);
  for (uint32 j = 0 to mtimes) {
    _crypto_core_salsa20(ref block, in, kcopy);
    secret mut uint8[64] cview = arrview(c, j*64, 64);
    secret uint8[64] mview = arrview(m, j*64, 64);
    for (uint32 i = 0 to 64) {
      cview[i] = mview[i] ^ block[i];
    }
    secret mut uint32 u = 1;
    for (uint32 i = 8 to 16) {
      u += in[i];
      in[i] = (uint8)u;
      u >>= 8;
    }
  }
  if (mtimes * 64 < len m) {
    public uint32 remain = len m - mtimes * 64;
    _crypto_core_salsa20(ref block, in, kcopy);
    secret mut uint8[] cview = arrview(c, mtimes*64, remain);
    secret uint8[] mview = arrview(m, mtimes*64, remain);
    for (uint32 i = 0 to remain) {
      cview[i] = mview[i] ^ block[i];
    }
  }
  _memzero(ref block);
  _memzero(ref kcopy);
  return 0;
}

export
public int32 _crypto_stream_xsalsa20(
    secret mut uint8[] c,
    public uint8[24] n,
    secret uint8[32] k) {
  secret mut uint8[32] subkey = noinit(32);
  _crypto_core_hsalsa20(ref subkey, arrview(n, 0, 16), k);
  public int32 ret = _crypto_stream_salsa20(ref c, arrview(n, 16, 8), subkey);
  _fact_memzero(ref subkey);
  return ret;
}

export
public int32 _crypto_stream_xsalsa20_xor_ic(
    secret mut uint8[] c,
    secret uint8[] m,
    public uint8[24] n,
    public uint64 ic,
    secret uint8[32] k) {
  secret mut uint8[32] subkey = noinit(32);
  _crypto_core_hsalsa20(ref subkey, arrview(n, 0, 16), k);
  public uint8[8] tmp = arrview(n, 16, 8);
  public int32 ret = _crypto_stream_salsa20_xor_ic(ref c, m, tmp, ic, subkey);
  _fact_memzero(ref subkey);
  return ret;
}

public int32 _crypto_stream_xsalsa20_xor(
    secret mut uint8[] c,
    secret uint8[] m,
    public uint8[24] n,
    secret uint8[32] k) {
  return _crypto_stream_xsalsa20_xor_ic(ref c, m, n, 0, k);
}

export
public bool _crypto_secretbox_xsalsa20poly1305(
    secret mut uint8[] c,
    secret uint8[] m,
    public uint8[24] n,
    secret uint8[32] k) {
  if (len m < 32) {
    return false;
  }

  _crypto_stream_xsalsa20_xor(ref c, m, n, k);
  secret mut uint8[16] cview = arrview(c, 16, 16);
  secret uint8[] mview = arrview(c, 32, len c - 32); // yes this is c and not m
  secret uint8[32] kview = arrview(c, 0, 32); // yes this is c and not k
  _crypto_onetimeauth_poly1305(ref cview, mview, kview);

  for (int32 i = 0 to 16) {
    c[i] = 0;
  }
  return true;
}

export
public bool _crypto_secretbox_xsalsa20poly1305_open(
    secret mut uint8[] m,
    secret uint8[] c,
    public uint8[24] n,
    secret uint8[32] k) {
  if (len c < 32) {
    return false;
  }

  secret mut uint8[32] subkey = noinit(32);
  _crypto_stream_xsalsa20(ref subkey, n, k);
  secret uint8[16] tmp1 = arrview(c, 16, 16);
  secret uint8[] cview = arrview(c, 32, len c - 32);
  if (!_crypto_onetimeauth_poly1305_verify(tmp1, cview, subkey)) {
    return false;
  }
  _crypto_stream_xsalsa20_xor(ref m, c, n, k);
  for (uint32 i = 0 to 32) {
    m[i] = 0;
  }

  return true;
}

export public bool _crypto_secretbox(
    secret mut uint8[] c,
    secret uint8[] m,
    public uint8[24] n,
    secret uint8[32] k) {
  return _crypto_secretbox_xsalsa20poly1305(ref c, m, n, k);
}

export public bool _crypto_secretbox_open(
    secret mut uint8[] m,
    secret uint8[] c,
    public uint8[24] n,
    secret uint8[32] k) {
  return _crypto_secretbox_xsalsa20poly1305_open(ref m, c, n, k);
}
