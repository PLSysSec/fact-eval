/*
 * typedef uint8_t u8
 * typedef int32_t s32
 * typedef int64_t limb
 */

/* Sum two numbers: output += in */
void
_fsum(secret mut int64[10] output,
     secret int64[10] in)
{
  for (uint8 i = 0; i < 10; i += 2) {
    output[0+i] = output[0+i] + in[0+i];
    output[1+i] = output[1+i] + in[1+i];
  }
}

/* Find the difference of two numbers: output = in - output */
void
_fdifference(secret mut int64[10] output,
            secret int64[10] in)
{
  for(uint8 i = 0; i < 10; i += 1) {
    output[i] = in[i] - output[i];
  }
}

/* Multiply a number by a scalar: output = in * scalar */
void
_fscalar_product(secret mut int64[10] output,
                secret int64[10] in,
                secret int64 scalar)
{
  for(uint8 i = 0; i < 10; i += 1) {
    output[i] = in[i] * scalar;
  }
}

/* Multiply two numbers: output = in2 * in
 *
 * output must be distinct to both inputs. The inputs are
 * reduced coefficient form, the output is not.
 *
 * output[x] <= 14 * the largest product of the input limb */
void
_fproduct(secret mut int64[19] output,
         secret int64[10] in2,
         secret int64[10] in)
{
  output[0] =       ((int64) ((int32) in2[0])) * ((int32) in[0]);
  output[1] =       ((int64) ((int32) in2[0])) * ((int32) in[1]) +
                    ((int64) ((int32) in2[1])) * ((int32) in[0]);
  output[2] =  2 *  ((int64) ((int32) in2[1])) * ((int32) in[1]) +
                    ((int64) ((int32) in2[0])) * ((int32) in[2]) +
                    ((int64) ((int32) in2[2])) * ((int32) in[0]);
  output[3] =       ((int64) ((int32) in2[1])) * ((int32) in[2]) +
                    ((int64) ((int32) in2[2])) * ((int32) in[1]) +
                    ((int64) ((int32) in2[0])) * ((int32) in[3]) +
                    ((int64) ((int32) in2[3])) * ((int32) in[0]);
  output[4] =       ((int64) ((int32) in2[2])) * ((int32) in[2]) +
               2 * (((int64) ((int32) in2[1])) * ((int32) in[3]) +
                    ((int64) ((int32) in2[3])) * ((int32) in[1])) +
                    ((int64) ((int32) in2[0])) * ((int32) in[4]) +
                    ((int64) ((int32) in2[4])) * ((int32) in[0]);
  output[5] =       ((int64) ((int32) in2[2])) * ((int32) in[3]) +
                    ((int64) ((int32) in2[3])) * ((int32) in[2]) +
                    ((int64) ((int32) in2[1])) * ((int32) in[4]) +
                    ((int64) ((int32) in2[4])) * ((int32) in[1]) +
                    ((int64) ((int32) in2[0])) * ((int32) in[5]) +
                    ((int64) ((int32) in2[5])) * ((int32) in[0]);
  output[6] =  2 * (((int64) ((int32) in2[3])) * ((int32) in[3]) +
                    ((int64) ((int32) in2[1])) * ((int32) in[5]) +
                    ((int64) ((int32) in2[5])) * ((int32) in[1])) +
                    ((int64) ((int32) in2[2])) * ((int32) in[4]) +
                    ((int64) ((int32) in2[4])) * ((int32) in[2]) +
                    ((int64) ((int32) in2[0])) * ((int32) in[6]) +
                    ((int64) ((int32) in2[6])) * ((int32) in[0]);
  output[7] =       ((int64) ((int32) in2[3])) * ((int32) in[4]) +
                    ((int64) ((int32) in2[4])) * ((int32) in[3]) +
                    ((int64) ((int32) in2[2])) * ((int32) in[5]) +
                    ((int64) ((int32) in2[5])) * ((int32) in[2]) +
                    ((int64) ((int32) in2[1])) * ((int32) in[6]) +
                    ((int64) ((int32) in2[6])) * ((int32) in[1]) +
                    ((int64) ((int32) in2[0])) * ((int32) in[7]) +
                    ((int64) ((int32) in2[7])) * ((int32) in[0]);
  output[8] =       ((int64) ((int32) in2[4])) * ((int32) in[4]) +
               2 * (((int64) ((int32) in2[3])) * ((int32) in[5]) +
                    ((int64) ((int32) in2[5])) * ((int32) in[3]) +
                  ((int64) ((int32) in2[1])) * ((int32) in[7]) +
                    ((int64) ((int32) in2[7])) * ((int32) in[1])) +
                    ((int64) ((int32) in2[2])) * ((int32) in[6]) +
                    ((int64) ((int32) in2[6])) * ((int32) in[2]) +
                    ((int64) ((int32) in2[0])) * ((int32) in[8]) +
                    ((int64) ((int32) in2[8])) * ((int32) in[0]);
  output[9] =       ((int64) ((int32) in2[4])) * ((int32) in[5]) +
                    ((int64) ((int32) in2[5])) * ((int32) in[4]) +
                    ((int64) ((int32) in2[3])) * ((int32) in[6]) +
                    ((int64) ((int32) in2[6])) * ((int32) in[3]) +
                    ((int64) ((int32) in2[2])) * ((int32) in[7]) +
                    ((int64) ((int32) in2[7])) * ((int32) in[2]) +
                    ((int64) ((int32) in2[1])) * ((int32) in[8]) +
                    ((int64) ((int32) in2[8])) * ((int32) in[1]) +
                    ((int64) ((int32) in2[0])) * ((int32) in[9]) +
                    ((int64) ((int32) in2[9])) * ((int32) in[0]);
  output[10] = 2 * (((int64) ((int32) in2[5])) * ((int32) in[5]) +
                    ((int64) ((int32) in2[3])) * ((int32) in[7]) +
                    ((int64) ((int32) in2[7])) * ((int32) in[3]) +
                    ((int64) ((int32) in2[1])) * ((int32) in[9]) +
                    ((int64) ((int32) in2[9])) * ((int32) in[1])) +
                    ((int64) ((int32) in2[4])) * ((int32) in[6]) +
                    ((int64) ((int32) in2[6])) * ((int32) in[4]) +
                    ((int64) ((int32) in2[2])) * ((int32) in[8]) +
                    ((int64) ((int32) in2[8])) * ((int32) in[2]);
  output[11] =      ((int64) ((int32) in2[5])) * ((int32) in[6]) +
                    ((int64) ((int32) in2[6])) * ((int32) in[5]) +
                    ((int64) ((int32) in2[4])) * ((int32) in[7]) +
                    ((int64) ((int32) in2[7])) * ((int32) in[4]) +
                    ((int64) ((int32) in2[3])) * ((int32) in[8]) +
                    ((int64) ((int32) in2[8])) * ((int32) in[3]) +
                    ((int64) ((int32) in2[2])) * ((int32) in[9]) +
                    ((int64) ((int32) in2[9])) * ((int32) in[2]);
  output[12] =      ((int64) ((int32) in2[6])) * ((int32) in[6]) +
               2 * (((int64) ((int32) in2[5])) * ((int32) in[7]) +
                    ((int64) ((int32) in2[7])) * ((int32) in[5]) +
                    ((int64) ((int32) in2[3])) * ((int32) in[9]) +
                    ((int64) ((int32) in2[9])) * ((int32) in[3])) +
                    ((int64) ((int32) in2[4])) * ((int32) in[8]) +
                    ((int64) ((int32) in2[8])) * ((int32) in[4]);
  output[13] =      ((int64) ((int32) in2[6])) * ((int32) in[7]) +
                    ((int64) ((int32) in2[7])) * ((int32) in[6]) +
                    ((int64) ((int32) in2[5])) * ((int32) in[8]) +
                    ((int64) ((int32) in2[8])) * ((int32) in[5]) +
                    ((int64) ((int32) in2[4])) * ((int32) in[9]) +
                    ((int64) ((int32) in2[9])) * ((int32) in[4]);
  output[14] = 2 * (((int64) ((int32) in2[7])) * ((int32) in[7]) +
                    ((int64) ((int32) in2[5])) * ((int32) in[9]) +
                    ((int64) ((int32) in2[9])) * ((int32) in[5])) +
                    ((int64) ((int32) in2[6])) * ((int32) in[8]) +
                    ((int64) ((int32) in2[8])) * ((int32) in[6]);
  output[15] =      ((int64) ((int32) in2[7])) * ((int32) in[8]) +
                    ((int64) ((int32) in2[8])) * ((int32) in[7]) +
                    ((int64) ((int32) in2[6])) * ((int32) in[9]) +
                    ((int64) ((int32) in2[9])) * ((int32) in[6]);
  output[16] =      ((int64) ((int32) in2[8])) * ((int32) in[8]) +
               2 * (((int64) ((int32) in2[7])) * ((int32) in[9]) +
                    ((int64) ((int32) in2[9])) * ((int32) in[7]));
  output[17] =      ((int64) ((int32) in2[8])) * ((int32) in[9]) +
                    ((int64) ((int32) in2[9])) * ((int32) in[8]);
  output[18] = 2 *  ((int64) ((int32) in2[9])) * ((int32) in[9]);
}

/* Reduce a long form to a short form by taking the input
 * mod 2^255 - 19
 *
 * On entry: |output[i]| < 14*2^54
 * On exit: |output[0..8]| < 280*2^54 */
void
_freduce_degree(secret mut int64[19] output)
{
  output[8] += output[18] << 4;
  output[8] += output[18] << 1;
  output[8] += output[18];
  output[7] += output[17] << 4;
  output[7] += output[17] << 1;
  output[7] += output[17];
  output[6] += output[16] << 4;
  output[6] += output[16] << 1;
  output[6] += output[16];
  output[5] += output[15] << 4;
  output[5] += output[15] << 1;
  output[5] += output[15];
  output[4] += output[14] << 4;
  output[4] += output[14] << 1;
  output[4] += output[14];
  output[3] += output[13] << 4;
  output[3] += output[13] << 1;
  output[3] += output[13];
  output[2] += output[12] << 4;
  output[2] += output[12] << 1;
  output[2] += output[12];
  output[1] += output[11] << 4;
  output[1] += output[11] << 1;
  output[1] += output[11];
  output[0] += output[10] << 4;
  output[0] += output[10] << 1;
  output[0] += output[10];
}

/* The following code only works on a two's complement system */

/* return v / 2^26, using only shifts and adds.
 *
 * On entry: v can take any value. */
inline
secret int64
div_by_2_26(secret int64 v)
{
  secret uint32 highword = (uint32) (((uint64) v) >> 32);
  secret int32 sign = ((int32) highword) >> 31;
  secret int32 roundoff = (int32) (((uint32) sign) >> 6);
  return (v + roundoff) >> 26;
}

/* return v / (2^25), using only shifts and adds.
 *
 * On entry: v can take any value. */
inline
secret int64
div_by_2_25(secret int64 v)
{
  secret uint32 highword = (uint32) (((uint64) v) >> 32);
  secret int32 sign = ((int32) highword) >> 31;
  secret int32 roundoff = (int32) (((uint32) sign) >> 7);
  return (v + roundoff) >> 25;
}

/* Reduce all coefficients of the short form input so that
 * |x| < 2^26.
 *
 * On entry: |output[i]| < 280*2^54 */
void
_freduce_coefficients(secret mut int64[11] output)
{
  output[10] = 0;

  for(uint8 i = 0; i < 10; i += 2) {
    secret mut int64 over = div_by_2_26(output[i]);

    output[i] -= over << 26;
    output[i+1] += over;

    over = div_by_2_25(output[i+1]);
    output[i+1] -= over << 25;
    output[i+2] += over;
  }

  output[0] += output[10] << 4;
  output[0] += output[10] << 1;
  output[0] += output[10];

  output[10] = 0;

  //XXX: why do we need a block here in the original code?
  //XXX: it seems like fact does not support this syntax?

  secret int64 over = div_by_2_26(output[0]);
  output[0] -= over << 26;
  output[1] += over;

}

/* A helpful wrapper around _fproduct: output = in * in2.
 *
 * On entry: |in[i]| < 2^27 and |in2[i]| < 2^27.
 *
 * output must be distinct to both inputs. The output is reduced degree
 * (indeed, one need only provide storage for 10 limbs) and
 * |output[i]| < 2^26. */
void
_fmul(secret mut int64[10] output,
     secret int64[10] in,
     secret int64[10] in2)
{
  secret mut int64[19] t = arrzeros(19);
  _fproduct(ref t, in, in2);
  /* |t[i]| < 14*2^54 */
  _freduce_degree(ref t);
  _freduce_coefficients(ref arrview(t, 0, 11));
  /* |t[i]| < 2^26 */
  pmemcpy_64(ref output, arrview(t, 0, 10));
}

/* Square a number: output = in**2
 *
 * output must be distinct from the input. The inputs are reduced coefficient
 * form, the ouput is not.
 *
 * output[x] <= 14 * the largest product of the input limbs */
void
_fsquare_inner(secret mut int64[19] output,
              secret int64[10] in)
{
  output[0] =       ((int64) ((int32) in[0])) * ((int32) in[0]);
  output[1] =  2 *  ((int64) ((int32) in[0])) * ((int32) in[1]);
  output[2] =  2 * (((int64) ((int32) in[1])) * ((int32) in[1]) +
                    ((int64) ((int32) in[0])) * ((int32) in[2]));
  output[3] =  2 * (((int64) ((int32) in[1])) * ((int32) in[2]) +
                    ((int64) ((int32) in[0])) * ((int32) in[3]));
  output[4] =       ((int64) ((int32) in[2])) * ((int32) in[2]) +
               4 *  ((int64) ((int32) in[1])) * ((int32) in[3]) +
               2 *  ((int64) ((int32) in[0])) * ((int32) in[4]);
  output[5] =  2 * (((int64) ((int32) in[2])) * ((int32) in[3]) +
                    ((int64) ((int32) in[1])) * ((int32) in[4]) +
                    ((int64) ((int32) in[0])) * ((int32) in[5]));
  output[6] =  2 * (((int64) ((int32) in[3])) * ((int32) in[3]) +
                    ((int64) ((int32) in[2])) * ((int32) in[4]) +
                    ((int64) ((int32) in[0])) * ((int32) in[6]) +
               2 *  ((int64) ((int32) in[1])) * ((int32) in[5]));
  output[7] =  2 * (((int64) ((int32) in[3])) * ((int32) in[4]) +
                    ((int64) ((int32) in[2])) * ((int32) in[5]) +
                    ((int64) ((int32) in[1])) * ((int32) in[6]) +
                    ((int64) ((int32) in[0])) * ((int32) in[7]));
  output[8] =       ((int64) ((int32) in[4])) * ((int32) in[4]) +
               2 * (((int64) ((int32) in[2])) * ((int32) in[6]) +
                    ((int64) ((int32) in[0])) * ((int32) in[8]) +
               2 * (((int64) ((int32) in[1])) * ((int32) in[7]) +
                    ((int64) ((int32) in[3])) * ((int32) in[5])));
  output[9] =  2 * (((int64) ((int32) in[4])) * ((int32) in[5]) +
                    ((int64) ((int32) in[3])) * ((int32) in[6]) +
                    ((int64) ((int32) in[2])) * ((int32) in[7]) +
                    ((int64) ((int32) in[1])) * ((int32) in[8]) +
                    ((int64) ((int32) in[0])) * ((int32) in[9]));
  output[10] = 2 * (((int64) ((int32) in[5])) * ((int32) in[5]) +
                    ((int64) ((int32) in[4])) * ((int32) in[6]) +
                    ((int64) ((int32) in[2])) * ((int32) in[8]) +
               2 * (((int64) ((int32) in[3])) * ((int32) in[7]) +
                    ((int64) ((int32) in[1])) * ((int32) in[9])));
  output[11] = 2 * (((int64) ((int32) in[5])) * ((int32) in[6]) +
                    ((int64) ((int32) in[4])) * ((int32) in[7]) +
                    ((int64) ((int32) in[3])) * ((int32) in[8]) +
                    ((int64) ((int32) in[2])) * ((int32) in[9]));
  output[12] =      ((int64) ((int32) in[6])) * ((int32) in[6]) +
               2 * (((int64) ((int32) in[4])) * ((int32) in[8]) +
               2 * (((int64) ((int32) in[5])) * ((int32) in[7]) +
                    ((int64) ((int32) in[3])) * ((int32) in[9])));
  output[13] = 2 * (((int64) ((int32) in[6])) * ((int32) in[7]) +
                    ((int64) ((int32) in[5])) * ((int32) in[8]) +
                    ((int64) ((int32) in[4])) * ((int32) in[9]));
  output[14] = 2 * (((int64) ((int32) in[7])) * ((int32) in[7]) +
                    ((int64) ((int32) in[6])) * ((int32) in[8]) +
               2 *  ((int64) ((int32) in[5])) * ((int32) in[9]));
  output[15] = 2 * (((int64) ((int32) in[7])) * ((int32) in[8]) +
                    ((int64) ((int32) in[6])) * ((int32) in[9]));
  output[16] =      ((int64) ((int32) in[8])) * ((int32) in[8]) +
               4 *  ((int64) ((int32) in[7])) * ((int32) in[9]);
  output[17] = 2 *  ((int64) ((int32) in[8])) * ((int32) in[9]);
  output[18] = 2 *  ((int64) ((int32) in[9])) * ((int32) in[9]);
}

/* _fsquare sets output = in^2.
 *
 * On entry: The |in| argument is in reduced coefficients form and
 * |in[i]| < 2^27
 *
 * On exit: The |output| argument is in reduced coefficients form
 * (indeed, one need only provide storage for 10 limbs) and
 * |out[i]| < 2^26. */
void
_fsquare(secret mut int64[10] output,
        secret int64[10] in)
{
  secret mut int64[19] t = arrzeros(19);
  _fsquare_inner(ref t, in);

  _freduce_degree(ref arrview(t, 0, 19));
  _freduce_coefficients(ref arrview(t, 0, 11));

  pmemcpy_64(ref output, arrview(t, 0, 10));
}

/* Take a little-endian, 32-byte number and expand it into polynomial form */
inline
void
fexpand_F(secret mut int64 output,
          secret uint8[4] input,
          public uint8 shift,
          public int32 mask)
{
  output = ((((int64) input[0]) | ((int64) input[1]) << 8 |
                ((int64) input[2]) << 16 |
                ((int64) input[3]) << 24) >> (int32) shift) & mask;
}

void
_fexpand(secret mut int64[10] output,
        secret uint8[32] input)
{
  //XXX: #defin F
  //currently I just move F out of the function
  fexpand_F(ref output[0], arrview(input,  0, 4), 0, 0x3ffffff);
  fexpand_F(ref output[1], arrview(input,  3, 4), 2, 0x1ffffff);
  fexpand_F(ref output[2], arrview(input,  6, 4), 3, 0x3ffffff);
  fexpand_F(ref output[3], arrview(input,  9, 4), 5, 0x1ffffff);
  fexpand_F(ref output[4], arrview(input, 12, 4), 6, 0x3ffffff);
  fexpand_F(ref output[5], arrview(input, 16, 4), 0, 0x1ffffff);
  fexpand_F(ref output[6], arrview(input, 19, 4), 1, 0x3ffffff);
  fexpand_F(ref output[7], arrview(input, 22, 4), 3, 0x1ffffff);
  fexpand_F(ref output[8], arrview(input, 25, 4), 4, 0x3ffffff);
  fexpand_F(ref output[9], arrview(input, 28, 4), 6, 0x1ffffff);
}

//XXX:here I just assume the if condition is always met
/* This code only works when >> does sign-extension on negative numbers */

/* s32_eq returns 0xffffffff iff a == b and zero otherwise. */
secret int32
s32_eq(secret int32 a,
       secret int32 b)
{
  secret mut int32 a_ = a;
  a_ = ~(a_ ^ b);
  a_ &= a_ << 16;
  a_ &= a_ << 8;
  a_ &= a_ << 4;
  a_ &= a_ << 2;
  a_ &= a_ << 1;
  return a_ >> 31;
}

/* s32_gte returns 0xffffffff if a >= b and zero otherwise, where
 * a and b are both non-negative */
secret int32
s32_gte(secret int32 a,
        secret int32 b)
{
  secret mut int32 a_ = a;
  a_ -= b;
  return ~(a_ >> 31);
}

/* Take a fully reduced polynomial form number and contract it
 * into a little-endian, 32-byte array. */
inline
void
fcontract_F(secret mut uint8[4] output,
            secret int32 input)
{
  output[0] |= (uint8) (input & 0xff);
  output[1] = (uint8) ((input >> 8) & 0xff);
  output[2] = (uint8) ((input >> 16) & 0xff);
  output[3] = (uint8) ((input >> 24) & 0xff);
}

void
_fcontract(secret mut uint8[32] output,
          secret int64[10] input_limbs)
{
  secret mut int32[10] input = arrzeros(10);
  secret mut int32 mask = 0;
  secret mut int32 carry = 0;

  for (uint8 i = 0; i < 10; i += 1) {
    //XXX: here input is int32[] and input_limbs is int64[]
    // will it be automatically downcasted? No
    input[i] = (int32) input_limbs[i];
  }

  for (uint8 j = 0; j < 2; j += 1) {
    for (uint8 i = 0; i < 9; i += 1) {
      if ((i & 1) == 1) {
        mask = input[i] >> 31;
        carry = -((input[i] & mask) >> 25);
        input[i] = input[i] + (carry << 25);
        input[i+1] = input[i+1] - carry;
      } else {
        mask = input[i] >> 31;
        carry = -((input[i] & mask) >> 26);
        input[i] = input[i] + (carry << 26);
        input[i+1] = input[i+1] - carry;
      }
    }
  }

  //XXX: again, what is the block for?
  //XXX: and the syntax is not supported in fact
  mask = input[9] >> 31;
  carry = -((input[9] & mask) >> 25);
  input[9] = input[9] + (carry << 25);
  input[0] = input[0] - (carry * 19);

  //XXX: also a block here
  mask = input[0] >> 31;
  carry = -((input[0] & mask) >> 26);
  input[0] = input[0] + (carry << 26);
  input[1] = input[1] - carry;

  for (uint8 j = 0; j < 2; j += 1) {
    for (uint8 i = 0; i < 9; i += 1) {
      if ((i & 1) == 1) {
        carry = input[i] >> 25;
        input[i] &= 0x1ffffff;
        input[i+1] += carry;
      } else {
        carry = input[i] >> 26;
        input[i] &= 0x3ffffff;
        input[i+1] += carry;
      }
    }

    carry = input[9] >> 25;
    input[9] &= 0x1ffffff;
    input[0] += 19 * carry;
  }

  mask = s32_gte(input[0], 0x3ffffed);
  for (uint8 i = 1; i < 10; i += 1) {
    if ((i & 1) == 1) {
      mask &= s32_eq(input[i], 0x1ffffff);
    } else {
      mask &= s32_eq(input[i], 0x3ffffff);
    }
  }

  /* mask is either 0xffffffff and zero otherwise */
  input[0] -= mask & 0x3ffffed;

  for (uint8 i = 1; i < 10; i += 1) {
    if ((i & 1) == 1) {
      input[i] -= mask & 0x1ffffff;
    } else {
      input[i] -= mask & 0x3ffffff;
    }
  }

  input[1] = input[1] << 2;
  input[2] = input[2] << 3;
  input[3] = input[3] << 5;
  input[4] = input[4] << 6;
  input[6] = input[6] << 1;
  input[7] = input[7] << 3;
  input[8] = input[8] << 4;
  input[9] = input[9] << 6;

  //XXX: I moved inline function F out to fcontract_F
  output[0] = 0;
  output[16] = 0;
  fcontract_F(ref arrview(output,  0, 4), input[0]);
  fcontract_F(ref arrview(output,  3, 4), input[1]);
  fcontract_F(ref arrview(output,  6, 4), input[2]);
  fcontract_F(ref arrview(output,  9, 4), input[3]);
  fcontract_F(ref arrview(output, 12, 4), input[4]);
  fcontract_F(ref arrview(output, 16, 4), input[5]);
  fcontract_F(ref arrview(output, 19, 4), input[6]);
  fcontract_F(ref arrview(output, 22, 4), input[7]);
  fcontract_F(ref arrview(output, 25, 4), input[8]);
  fcontract_F(ref arrview(output, 28, 4), input[9]);
}

/* Input: Q, Q', Q-Q'
 * Output: 2Q, Q+Q'
 *
 *   x2 z3: long form
 *   x3 z3: long form
 *   x z: short form, destroyed
 *   xprime zprime: short form, destroyed
 *   qmqp: short form, preserved
 *
 * On entry and exit, the absolute value of the limbs of all inputs and outputs
 * are < 2^26. */
void
_fmonty(secret mut int64[19] x2,
       secret mut int64[19] z2,
       secret mut int64[10] x3,
       secret mut int64[10] z3,
       secret mut int64[10] x,
       secret mut int64[10] z,
       secret mut int64[10] xprime,
       secret mut int64[10] zprime,
       secret int64[10] qmqp)
{
  secret mut int64[10] origx = arrzeros(10);
  secret mut int64[10] origxprime = arrzeros(10);
  secret mut int64[19] zzz = arrzeros(19);
  secret mut int64[19] xx = arrzeros(19);
  secret mut int64[19] zz = arrzeros(19);
  secret mut int64[19] xxprime = arrzeros(19);
  secret mut int64[19] zzprime = arrzeros(19);
  secret mut int64[19] zzzprime = arrzeros(19);
  secret mut int64[19] xxxprime = arrzeros(19);

  pmemcpy_64(ref origx, x);

  _fsum(ref x, z);
  _fdifference(ref z, origx);

  pmemcpy_64(ref origxprime, xprime);
  _fsum(ref xprime, zprime);
  /* |xprime[i]| < 2^27 */
  _fdifference(ref zprime, origxprime);
  /* |zprime[i]| < 2^27 */
  _fproduct(ref xxprime, xprime, z);
  /* |xxprime[i]| < 14*2^54: the largest product of two limbs will be <
   * 2^(27+27) and _fproduct adds together, at most, 14 of those products.
   * (Approximating that to 2^58 doesn't work out.) */
  _fproduct(ref zzprime, x, zprime);
  /* |zzprime[i]| < 14*2^54 */
  _freduce_degree(ref xxprime);
  _freduce_coefficients(ref arrview(xxprime, 0, 11));
  /* |xxprime[i]| < 2^26 */
  _freduce_degree(ref zzprime);
  _freduce_coefficients(ref arrview(zzprime, 0, 11));
  /* |zzprime[i]| < 2^26 */
  pmemcpy_64(ref origxprime, arrview(xxprime, 0, 10));
  _fsum(ref arrview(xxprime, 0, 10), arrview(zzprime, 0, 10));
  /* |xxprime[i]| < 2^27 */
  _fdifference(ref arrview(zzprime, 0, 10), origxprime);
  /* |zzprime[i]| < 2^27 */
  _fsquare(ref arrview(xxxprime, 0, 10), arrview(xxprime, 0, 10));
  /* |xxxprime[i]| < 2^26 */
  _fsquare(ref arrview(zzzprime, 0, 10), arrview(zzprime, 0, 10));
  /* |zzzprime[i]| < 2^26 */
  _fproduct(ref zzprime, arrview(zzzprime, 0, 10), qmqp);
  /* |zzprime[i]| < 14*2^52 */
  _freduce_degree(ref zzprime);
  _freduce_coefficients(ref arrview(zzprime, 0, 11));
  /* |zzprime[i]| < 2^26 */

  pmemcpy_64(ref x3, arrview(xxxprime, 0, 10));
  pmemcpy_64(ref z3, arrview(zzprime, 0, 10));

  _fsquare(ref arrview(xx, 0, 10), x);
  /* |xx[i]| < 2^26 */
  _fsquare(ref arrview(zz, 0, 10), z);
  /* |zz[i]| < 2^26 */
  _fproduct(ref x2, arrview(xx, 0, 10), arrview(zz, 0, 10));
  /* |x2[i]| < 14*2^52 */
  _freduce_degree(ref x2);
  _freduce_coefficients(ref arrview(x2, 0, 11));
  /* |x2[i]| < 2^26 */
  _fdifference(ref arrview(zz, 0, 10), arrview(xx, 0, 10));  // does zz = xx - zz
  /* |zz[i]| < 2^27 */

  memset_64(ref zzz, 10, 9, 0);

  _fscalar_product(ref arrview(zzz, 0, 10), arrview(zz, 0, 10), 121665);
  /* |zzz[i]| < 2^(27+17) */
  /* No need to call _freduce_degree here:
     _fscalar_product doesn't increase the degree of its input. */
  _freduce_coefficients(ref arrview(zzz, 0, 11));
  /* |zzz[i]| < 2^26 */
  _fsum(ref arrview(zzz, 0, 10), arrview(xx, 0, 10));
  /* |zzz[i]| < 2^27 */
  _fproduct(ref z2, arrview(zz, 0, 10), arrview(zzz, 0, 10));
  /* |z2[i]| < 14*2^(26+27) */
  _freduce_degree(ref z2);
  _freduce_coefficients(ref arrview(z2, 0, 11));
  /* |z2|i| < 2^26 */
}

/* Conditional swap in constant time */
void
_swap_conditional(secret mut int64[19] a,
                 secret mut int64[19] b,
                 secret int64 iswap)
{
  secret int32 swap = (int32) -iswap;

  for (uint8 i = 0; i < 10; i += 1) {
    secret int32 x = swap & (((int32) a[i]) ^ ((int32) b[i]));
    a[i] = ((int32) a[i]) ^ x;
    b[i] = ((int32) b[i]) ^ x;
  }
}

void
_cmult(secret mut int64[10] resultx,
      secret mut int64[10] resultz,
      secret uint8[32] n,
      secret int64[10] q)
{
  //XXX: stdlib function to initialize array with non-zero values
  secret mut int64[19] a = arrzeros(19);
  secret mut int64[19] b = arrzeros(19);
  initarr_64(ref b, 1, 19);
  secret mut int64[19] c = arrzeros(19);
  initarr_64(ref c, 1, 19);
  secret mut int64[19] d = arrzeros(19);

  secret mut int64[] nqpqx = arrview(a, 0, 19);
  secret mut int64[] nqpqz = arrview(b, 0, 19);
  secret mut int64[] nqx = arrview(c, 0, 19);
  secret mut int64[] nqz = arrview(d, 0, 19);
  //XXX: there is a pointer limb *t
  // might need to do some trick here to replace t
  // or do we have array assignment (hope their length are all 19)?

  //XXX: stdlib function to initialize array with non-zero values
  secret mut int64[19] e = arrzeros(19);
  secret mut int64[19] f = arrzeros(19);
  initarr_64(ref f, 1, 19);
  secret mut int64[19] g = arrzeros(19);
  secret mut int64[19] h = arrzeros(19);
  initarr_64(ref h, 1, 19);

  secret mut int64[] nqpqx2 = arrview(e, 0, 19);
  secret mut int64[] nqpqz2 = arrview(f, 0, 19);
  secret mut int64[] nqx2 = arrview(g, 0, 19);
  secret mut int64[] nqz2 = arrview(h, 0, 19);

  pmemcpy_64(ref arrview(nqpqx, 0, 10), q);

  for (uint8 i = 0; i < 32; i += 1) {
    secret mut uint8 byte = n[31 - i];
    for (uint8 j = 0; j < 8; j += 1) {
      secret int64 bit = (int64) (byte >> 7);

      if ((j & 1) == 0) {
        _swap_conditional(ref nqx, ref nqpqx, bit);
        _swap_conditional(ref nqz, ref nqpqz, bit);
        _fmonty(ref nqx2, ref nqz2,
               ref arrview(nqpqx2, 0, 10), ref arrview(nqpqz2, 0, 10),
               ref arrview(nqx, 0, 10), ref arrview(nqz, 0, 10),
               ref arrview(nqpqx, 0, 10), ref arrview(nqpqz, 0, 10),
               q);
        _swap_conditional(ref nqx2, ref nqpqx2, bit);
        _swap_conditional(ref nqz2, ref nqpqz2, bit);
      } else {
        _swap_conditional(ref nqx2, ref nqpqx2, bit);
        _swap_conditional(ref nqz2, ref nqpqz2, bit);
        _fmonty(ref nqx, ref nqz,
               ref arrview(nqpqx, 0, 10), ref arrview(nqpqz, 0, 10),
               ref arrview(nqx2, 0, 10), ref arrview(nqz2, 0, 10),
               ref arrview(nqpqx2, 0, 10), ref arrview(nqpqz2, 0, 10),
               q);
        _swap_conditional(ref nqx, ref nqpqx, bit);
        _swap_conditional(ref nqz, ref nqpqz, bit);
      }

      byte <<= 1;
    }
  }

  pmemcpy_64(ref resultx, arrview(nqx, 0, 10));
  pmemcpy_64(ref resultz, arrview(nqz, 0, 10));
}

void
_crecip(secret mut int64[10] out,
       secret int64[10] z)
{
  secret mut int64[10] z2 = arrzeros(10);
  secret mut int64[10] z9 = arrzeros(10);
  secret mut int64[10] z11 = arrzeros(10);
  secret mut int64[10] z2_5_0 = arrzeros(10);
  secret mut int64[10] z2_10_0 = arrzeros(10);
  secret mut int64[10] z2_20_0 = arrzeros(10);
  secret mut int64[10] z2_50_0 = arrzeros(10);
  secret mut int64[10] z2_100_0 = arrzeros(10);
  secret mut int64[10] t0 = arrzeros(10);
  secret mut int64[10] t1 = arrzeros(10);

  _fsquare(ref z2, z);
  _fsquare(ref t1, z2);
  _fsquare(ref t0, t1);
  _fmul(ref z9, t0, z);
  _fmul(ref z11, z9, z2);
  _fsquare(ref t0, z11);
  _fmul(ref z2_5_0, t0, z9);

  _fsquare(ref t0, z2_5_0);
  _fsquare(ref t1, t0);
  _fsquare(ref t0, t1);
  _fsquare(ref t1, t0);
  _fsquare(ref t0, t1);
  _fmul(ref z2_10_0, t0, z2_5_0);

  _fsquare(ref t0, z2_10_0);
  _fsquare(ref t1, t0);
  //XXX: the original code uses for (i = 2; i < 10; i += 2)
  // but i is never used inside the loop
  for (uint8 i = 2; i < 10; i += 2) {
    _fsquare(ref t0, t1);
    _fsquare(ref t1, t0);
  }
  _fmul(ref z2_20_0, t1, z2_10_0);

  _fsquare(ref t0, z2_20_0);
  _fsquare(ref t1, t0);
  for (uint8 i = 0; i < 9; i += 1) {
    _fsquare(ref t0, t1);
    _fsquare(ref t1, t0);
  }
  _fmul(ref t0, t1, z2_20_0);

  _fsquare(ref t1, t0);
  _fsquare(ref t0, t1);
  for (uint8 i = 2; i < 10; i += 2) {
    _fsquare(ref t1, t0);
    _fsquare(ref t0, t1);
  }
  _fmul(ref z2_50_0, t0, z2_10_0);

  _fsquare(ref t0, z2_50_0);
  _fsquare(ref t1, t0);
  for (uint8 i = 2; i < 50; i += 2) {
    _fsquare(ref t0, t1);
    _fsquare(ref t1, t0);
  }
  _fmul(ref z2_100_0, t1, z2_50_0);

  _fsquare(ref t1, z2_100_0);
  _fsquare(ref t0, t1);
  for (uint8 i = 2; i < 100; i += 2) {
    _fsquare(ref t1, t0);
    _fsquare(ref t0, t1);
  }
  _fmul(ref t1, t0, z2_100_0);

  _fsquare(ref t0, t1);
  _fsquare(ref t1, t0);
  for (uint8 i = 2; i < 50; i += 2) {
    _fsquare(ref t0, t1);
    _fsquare(ref t1, t0);
  }
  _fmul(ref t0, t1, z2_50_0);

  _fsquare(ref t1, t0);
  _fsquare(ref t0, t1);
  _fsquare(ref t1, t0);
  _fsquare(ref t0, t1);
  _fsquare(ref t1, t0);
  _fmul(ref out, t1, z11);
}

//XXX: should mypublic be secret or public?
// since _fcontract takes secret...
export
secret int32
_curve25519_donna(secret mut uint8[32] mypublic,
                 secret uint8[32] _secret,
                 secret uint8[32] basepoint)
{
  secret mut int64[10] bp = arrzeros(10);
  secret mut int64[10] x = arrzeros(10);
  secret mut int64[10] z = arrzeros(10);
  secret mut int64[10] zmone = arrzeros(10);
  secret mut uint8[32] e = arrzeros(32);

  for (uint8 i = 0; i < 32; i += 1) {
    e[i] = _secret[i];
  }

  e[0] &= 248;
  e[31] &= 127;
  e[31] |= 64;

  _fexpand(ref bp, basepoint);
  _cmult(ref x, ref z, e, bp);
  _crecip(ref zmone, z);
  _fmul(ref z, x, zmone);
  _fcontract(ref mypublic, z);
  return 0;
}
