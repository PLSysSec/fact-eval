/*
  mbedtls/include/bignum.h
  typedef  int64_t mbedtls_mpi_sint;
  typedef uint64_t mbedtls_mpi_uint;
*/

/*
  mbedtls/include/bignum.h:180
  struct mbedtls_mpi
    int s
    size_t n
    mbedtls_mpi_uint *p     //how should we handle the pointer here?
                            //it looks like a pointer to an array
*/

void _mpi_mul_hlp(
    public uint64 i,
    public uint64[] s,
    secret mut uint64[] d,
    secret uint64 b) { }

secret int32 _mbedtls_mpi_cmp_abs(
    secret int32 X_s,
    secret uint64[] X_p,
    secret int32 Y_s,
    secret uint64[] Y_p) {
  return 1;
}

void _mpi_sub_hlp(
    public uint64 n,
    public uint64[] s,
    secret mut uint64[] d) { }

/* mbedtls/library/bignum.c:1559 */
//currently just assign them all to public
public int32 _mpi_montmul(
  //mbedtls_mpi *A
  secret mut int32 A_s,
  secret mut uint64[] A_p,
  //const mbedtls_mpi *B
  public int32 B_s,
  public uint64[] B_p,
  //const mbedtls_mpi *N
  public mut int32 N_s,
  public mut uint64[] N_p,
  public uint64 mm,
  //const mbedtls_mpi *T
  secret mut int32 T_s,
  secret mut uint64[] T_p,
  secret bool actually_do) {

  /* do the NULL check in the c wrapper */

  if (actually_do) {
    public uint64 n = len N_p;
    public uint64 m = (len B_p < n) ? len B_p : n;

    //instead of memset use fact_memzero64, so no ciL needed
    //public mut uint64 ciL = 8;
    _fact_memzero64(ref T_p);

    for(uint64 i = 0; i < n; i += 1) {
      secret uint64 u0 = A_p[i];
      secret uint64 u1 = (T_p[i] + u0 * B_p[0]) * mm;

      //XXX we need to pass d to the helper function
      //not sure how to do that yet
      //update: maybe use an extra loop to manually copy
      //public uint64 d_len = T_n - T_p_ptr;
      //public mut uint64[d_len] d = arrzeros(d_len);
      //_partial64_copy(T_p, ref d, T_p_ptr);
      _mpi_mul_hlp(m, B_p, ref arrview(T_p, i, (len T_p) - i), u0);
      _mpi_mul_hlp(n, N_p, ref arrview(T_p, i, (len T_p) - i), u1);

      T_p[i] = u0;
      T_p[i + 1 + n + 1] = 0;
    }

    for(uint64 i = 0; i <= n; i += 1) {
      A_p[i] = T_p[n + i];
    }

    if(_mbedtls_mpi_cmp_abs(A_s, A_p, N_s, N_p) >= 0) {
      _mpi_sub_hlp(n, N_p, ref A_p);
    }
  }

  return 0;
}



