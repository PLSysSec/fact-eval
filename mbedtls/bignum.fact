/*
   mbedtls/include/bignum.h
   typedef  int64_t mbedtls_mpi_sint;
   typedef uint64_t mbedtls_mpi_uint;
 */

/*
   mbedtls/include/bignum.h:180
   struct mbedtls_mpi
   int s
   size_t n
   mbedtls_mpi_uint *p     //how should we handle the pointer here?
//it looks like a pointer to an array
 */


void _mpi_mul_hlp(
        public uint64 n,
        secret uint64[] s,
        secret mut uint64[] d,
        secret uint64 b) {
    secret mut uint64 c = 0;

    for (uint64 i = 0; i < n; i += 1) {
        secret uint128 r = s[i] * ((uint128)b);
        secret mut uint64 r0 = (uint64)r;
        secret mut uint64 r1 = (uint64)(r >> 64);
        r0 += c;
        r1 += r0 < c ? 1 : 0;
        r0 += d[i];
        r1 += r0 < d[i] ? 1 : 0;
        c = r1;
        d[i] = r0;
    }

    for (uint64 i = n; i < len d; i += 1) {
        d[i] += c;
        c = d[i] < c ? 1 : 0;
    }
}

secret int32 _mbedtls_mpi_cmp_abs(
        secret uint64[] X_p,
        secret uint64[] Y_p) {
    secret mut uint64 saved_i = 0;
    secret mut uint64 saved_j = 0;

    for (uint64 i = len X_p; i > 0; i -= 1) {
        if (saved_i == 0 && X_p[i - 1] != 0) {
            saved_i = i;
        }
    }

    for (uint64 j = len Y_p; j > 0; j -= 1) {
        if (saved_j == 0 && Y_p[j - 1] != 0) {
            saved_j = j;
        }
    }

    if (saved_i == 0 && saved_j == 0) {
        return 0;
    }

    if (saved_i > saved_j) {
        return 1;
    }
    if (saved_j > saved_i) {
        return -1;
    }

    for (uint64 i = len X_p; i > 0; i -= 1) {
        if (i <= saved_i) {
            if (X_p[i - 1] > Y_p[i - 1]) {
                return 1;
            }
            if (X_p[i - 1] < Y_p[i - 1]) {
                return -1;
            }
        }
    }

    return 0;
}

void _mpi_sub_hlp(
        public uint64 n,
        secret uint64[] s,
        secret mut uint64[] d) {
    secret mut uint64 c = 0;
    secret mut uint64 z = 0;

    for (uint64 i = 0; i < n; i += 1) {
        z = d[i] < c ? 1 : 0;
        d[i] -= c;
        c = (d[i] < s[i] ? 1 : 0) + z;
        d[i] -= s[i];
    }

    for (uint64 i = n; i < len d; i += 1) {
        z = (d[i] < c ? 1 : 0);
        d[i] -= c;
        c = z;
    }
}

void _mpi_montmul(
        //mbedtls_mpi *A
        secret mut uint64[] A_p,
        //const mbedtls_mpi *B
        secret uint64[] B_p,
        //const mbedtls_mpi *N
        secret uint64[] N_p,
        secret uint64 mm,
        //const mbedtls_mpi *T
        secret mut uint64[] T_p) {

    public uint64 n = len N_p;
    public uint64 m = (len B_p < n) ? len B_p : n;

    _memzero64(ref T_p);

    for(uint64 i = 0; i < n; i += 1) {
        secret uint64 u0 = A_p[i];
        secret uint64 u1 = (T_p[i] + (u0 * B_p[0])) * mm;

        _mpi_mul_hlp(m, B_p, ref arrview(T_p, i, (len T_p) - i), u0);
        _mpi_mul_hlp(n, N_p, ref arrview(T_p, i, (len T_p) - i), u1);

        T_p[i] = u0;
        T_p[i + 1 + n + 1] = 0;
    }

    for(uint64 i = 0; i <= n; i += 1) {
        A_p[i] = T_p[n + i];
    }

    if(_mbedtls_mpi_cmp_abs(A_p, N_p) >= 0) {
        _mpi_sub_hlp(n, N_p, ref A_p);
    }
}

// montgomery multiply with 1
void _mpi_montred(
        secret mut uint64[] A,
        secret uint64[] N,
        secret uint64 mm,
        secret mut uint64[] T) {

    secret uint64[1] one = { 1 };
    _mpi_montmul(ref A, one, N, mm, ref T);
}

// precondition: len TO >= len FROM
void _mpi_copy(secret mut uint64[] TO, secret uint64[] FROM) {
    for (uint32 i = 0; i < len FROM; i += 1) {
        TO[i] = FROM[i];
    }
    for (uint32 i = len FROM; i < len TO; i += 1) {
        TO[i] = 0;
    }
}

export
secret int32 _f_mpi_exp_mod(
        secret mut uint64[] X,
        secret uint64[] A,
        secret int32 A_sgn,
        secret uint64[] E,
        secret uint64[] N,
        secret uint64[] RR,
        secret mut uint64[] T,
        secret mut uint64[] W,
        secret mut uint64[] TW,
        secret uint64 mm) {

    public uint32 wlen = (len W) >> 4;
    secret mut int32 ret = 1;

    // X = R mod N
    _mpi_copy(ref X, RR);
    _mpi_montred(ref X, N, mm, ref T);

    // W[0] = R mod N
    _mpi_copy(ref arrview(W, 0, wlen), X);

    // W[1] = A R mod N
    _mpi_copy(ref arrview(W, wlen, wlen), A);
    _mpi_montmul(ref arrview(W, wlen, wlen), RR, N, mm, ref T);

    // W[i] = W[i-1] * W[1] * R^-1 mod N
    for (uint32 widx = 2; widx < 16; widx += 1) {
        _mpi_copy(ref arrview(W, widx * wlen, wlen), arrview(W, (widx - 1) * wlen, wlen));
        _mpi_montmul(ref arrview(W, widx * wlen, wlen), arrview(W, wlen, wlen), N, mm, ref T);
    }

    // windowed exponentiation
    for (uint32 limb = (len E) ; limb > 0; limb -= 1) {
        for (uint32 i = 1; i < 17; i += 1) {
            // square 4 times
            _mpi_montmul(ref X, X, N, mm, ref T);
            _mpi_montmul(ref X, X, N, mm, ref T);
            _mpi_montmul(ref X, X, N, mm, ref T);
            _mpi_montmul(ref X, X, N, mm, ref T);

            // mask 4 bits of exponent
            secret uint64 wbits = (E[limb-1] >> (64 - 4 * i)) & 0x0F;

            // select correct precomputed exponent value
            for (uint32 widx = 0; widx < 16; widx += 1) {
                if (wbits == widx) {
                    _mpi_copy(ref TW, arrview(W, widx * wlen, wlen));
                }
            }

            // multiply by exponent value
            _mpi_montmul(ref X, TW, N, mm, ref T);
        }
    }

    // divide by R, which results in X mod N
    _mpi_montred(ref X, N, mm, ref T);

    // fix sign, assuming N is positive
    secret bool need_fix_sign = (A_sgn < 0) && ((E[0] & 1) != 0);
    if (need_fix_sign) {
        // X is really -(N-X)
        ret = -1;
        _mpi_copy(ref T, N);
        _mpi_sub_hlp(len X, X, ref T);
        _mpi_copy(ref X, arrview(T, 0, len X));
    }

    return ret;
}

// vim: syntax=cpp
