/*
   mbedtls/include/bignum.h
   typedef  int64_t mbedtls_mpi_sint;
   typedef uint64_t mbedtls_mpi_uint;
 */

/*
   mbedtls/include/bignum.h:180
   struct mbedtls_mpi
   int s
   size_t n
   mbedtls_mpi_uint *p     //how should we handle the pointer here?
//it looks like a pointer to an array
 */


void _mpi_mul_hlp(
        public uint64 n,
        secret uint64[] s,
        secret mut uint64[] d,
        secret uint64 b) {
    assume(len s == n);
    assume(len d >= n);
    secret mut uint64 c = 0;

    for (uint64 i from 0 to n) {
        secret uint128 r = s[i] * uint128(b);
        secret mut uint64 r0 = uint64(r);
        secret mut uint64 r1 = uint64(r >> 64);
        r0 += c;
        r1 += r0 < c ? 1 : 0;
        r0 += d[i];
        r1 += r0 < d[i] ? 1 : 0;
        c = r1;
        d[i] = r0;
    }

    for (uint64 i from n to len d) {
        d[i] += c;
        c = d[i] < c ? 1 : 0;
    }
}

secret int32 _mbedtls_mpi_cmp_abs(
        secret uint64[] X_p,
        secret uint64[] Y_p) {
    secret mut uint64 saved_i = 0;
    secret mut uint64 saved_j = 0;

    for (uint64 _i from 0 to len X_p) {
        public uint64 i = len X_p - _i;
        if (saved_i == 0 && X_p[i - 1] != 0) {
            saved_i = i;
        }
    }

    for (uint64 _j from 0 to len Y_p) {
        public uint64 j = len Y_p - _j;
        if (saved_j == 0 && Y_p[j - 1] != 0) {
            saved_j = j;
        }
    }

    if (saved_i == 0 && saved_j == 0) {
        return 0;
    }

    if (saved_i > saved_j) {
        return 1;
    }
    if (saved_j > saved_i) {
        return -1;
    }

    public uint64 start_idx = (len X_p < len Y_p) ? len X_p : len Y_p;
    for (uint64 _i from 0 to start_idx) {
        public uint64 i = start_idx - _i;
        if (i <= saved_i) {
            if (X_p[i - 1] > Y_p[i - 1]) {
                return 1;
            }
            if (X_p[i - 1] < Y_p[i - 1]) {
                return -1;
            }
        }
    }

    return 0;
}

void _mpi_sub_hlp(
        public uint64 n,
        secret uint64[] s,
        secret mut uint64[] d) {
    assume(len s == n);
    assume(len d >= n);
    secret mut uint64 c = 0;
    secret mut uint64 z = 0;

    for (uint64 i from 0 to n) {
        z = d[i] < c ? 1 : 0;
        d[i] -= c;
        c = (d[i] < s[i] ? 1 : 0) + z;
        d[i] -= s[i];
    }

    for (uint64 i from n to len d) {
        z = (d[i] < c ? 1 : 0);
        d[i] -= c;
        c = z;
    }
}

void _mpi_montmul(
        //mbedtls_mpi *A
        secret mut uint64[] A_p,
        //const mbedtls_mpi *B
        secret uint64[] B_p,
        //const mbedtls_mpi *N
        secret uint64[] N_p,
        secret uint64 mm,
        //const mbedtls_mpi *T
        secret mut uint64[] T_p) {
    assume(len N_p * 2 + 2 > len N_p); // assume no overflow
    assume(len A_p >= len N_p + 1);
    assume(len T_p >= len N_p * 2 + 2);
    assume(len B_p > 0);

    public uint64 n = len N_p;
    public uint64 m = (len B_p < n) ? len B_p : n;
    for (uint64 i from 0 to len T_p) {
        T_p[i] = 0;
    }

    for(uint64 i from 0 to n) {
        secret uint64 u0 = A_p[i];
        secret uint64 u1 = (T_p[i] + (u0 * B_p[0])) * mm;

        _mpi_mul_hlp(m, B_p, view(T_p, i, (len T_p) - i), u0);
        _mpi_mul_hlp(n, N_p, view(T_p, i, (len T_p) - i), u1);

        T_p[i] = u0;
        T_p[i + 1 + n + 1] = 0;
    }

    for(uint64 i from 0 to n + 1) {
        A_p[i] = T_p[n + i];
    }

    if(_mbedtls_mpi_cmp_abs(A_p, N_p) >= 0) {
        _mpi_sub_hlp(n, N_p, A_p);
    }
}

// montgomery multiply with 1
void _mpi_montred(
        secret mut uint64[] A,
        secret uint64[] N,
        secret uint64 mm,
        secret mut uint64[] T) {

    secret uint64[1] one = [ 1 ];
    _mpi_montmul(A, one, N, mm, T);
}

void _mpi_copy(secret mut uint64[] TO, secret uint64[] FROM) {
    public uint64 clen = (len TO < len FROM) ? len TO : len FROM;
    for (uint64 i from 0 to clen) {
        TO[i] = FROM[i];
    }
    for (uint64 i from clen to len TO) {
        TO[i] = 0;
    }
}

export
secret int32 _f_mpi_exp_mod(
        secret mut uint64[] X,
        secret uint64[] A,
        secret int32 A_sgn,
        secret uint64[] E,
        secret uint64[] N,
        secret uint64[] RR,
        secret mut uint64[] T,
        secret mut uint64[] W,
        secret mut uint64[] TW,
        secret uint64 mm) {
    assume(len E > 0);
    assume(len T > len X);

    public uint32 wlen = uint32((len W) >> 4);
    secret mut int32 ret = 1;

    // X = R mod N
    _mpi_copy(X, RR);
    _mpi_montred(X, N, mm, T);

    // W[0] = R mod N
    _mpi_copy(view(W, 0, wlen), X);

    // W[1] = A R mod N
    _mpi_copy(view(W, wlen, wlen), A);
    _mpi_montmul(view(W, wlen, wlen), RR, N, mm, T);

    // W[i] = W[i-1] * W[1] * R^-1 mod N
    for (uint32 widx from 2 to 16) {
        _mpi_copy(view(W, widx * wlen, wlen), view(W, (widx - 1) * wlen, wlen));
        _mpi_montmul(view(W, widx * wlen, wlen), view(W, wlen, wlen), N, mm, T);
    }

    // windowed exponentiation
    for (uint64 _limb from 0 to len E) {
        public uint32 limb = uint32(len E - _limb);
        for (uint32 i from 1 to 17) {
            // square 4 times
            _mpi_montmul(X, X, N, mm, T);
            _mpi_montmul(X, X, N, mm, T);
            _mpi_montmul(X, X, N, mm, T);
            _mpi_montmul(X, X, N, mm, T);

            // mask 4 bits of exponent
            secret uint64 wbits = (E[limb-1] >> (64 - 4 * i)) & 0x0F;

            // select correct precomputed exponent value
            for (uint32 widx from 0 to 16) {
                if (wbits == widx) {
                    _mpi_copy(TW, view(W, widx * wlen, wlen));
                }
            }

            // multiply by exponent value
            _mpi_montmul(X, TW, N, mm, T);
        }
    }

    // divide by R, which results in X mod N
    _mpi_montred(X, N, mm, T);

    // fix sign, assuming N is positive
    secret bool need_fix_sign = (A_sgn < 0) && ((E[0] & 1) != 0);
    if (need_fix_sign) {
        // X is really -(N-X)
        ret = -1;
        _mpi_copy(T, N);
        _mpi_sub_hlp(len X, X, T);
        _mpi_copy(X, view(T, 0, len X));
    }

    return ret;
}

// vim: syntax=cpp
