extern void _memset(public mut uint64[] array, public uint64 value, public uint64 length);
extern void _mpi_mul_hlp(public uint64 i, public uint64[] s,
                        public mut uint64[] d, public uint64 b);
extern public int32 _mbedtls_mpi_cmp_abs(public int32 s_x, public uint64 n_x, 
                                       public uint64[] p_x, public int32 s_y, 
                                       public uint64 n_y, public uint64[] p_y);
extern public int32 _mpi_sub_hlp(public uint64 n, public mut uint64[] s, public mut uint64[] d);

/*
  mbedtls/include/bignum.h
  typedef  int64_t mbedtls_mpi_sint;
  typedef uint64_t mbedtls_mpi_uint;
*/

/*
  mbedtls/include/bignum.h:180
  struct mbedtls_mpi
    int s
    size_t n
    mbedtls_mpi_uint *p     //how should we handle the pointer here?
                            //it looks like a pointer to an array
*/

/* mbedtls/library/bignum.c:1559 */
//currently just assign them all to public
public int32 mpi_montmul(
  //mbedtls_mpi *A
  public mut int32 A_s,
  public mut uint64 A_n,
  public mut uint64[] A_p,
  //const mbedtls_mpi *B
  public int32 B_s,
  public uint64 B_n,
  public uint64[] B_p,
  //const mbedtls_mpi *N
  public mut int32 N_s,
  public mut uint64 N_n,
  public mut uint64[] N_p,
  //const mbedtls_mpi *T
  public mut int32 T_s,
  public mut uint64 T_n,
  public mut uint64[] T_p,
  public uint64 mm) {

  /* do the NULL check in the c wrapper */

  public uint64 n = N_n;
  public mut uint64 m = (B_n < n) ? B_n : n;
  public mut uint64 u0 = 0;
  public mut uint64 u1 = 0;
  //instead of d = T->p, just use d as an offset
  public mut uint64 T_p_ptr = 0;

  //instead of memset use fact_memzero64, so no ciL needed
  //public mut uint64 ciL = 8;
  _fact_memzero64_public(ref T_p);

  for(uint64 i = 0 to n) {
    u0 = A_p[i];
    u1 = (T_p[T_p_ptr] + u0 * B_p[0]) * mm;
    
    //XXX we need to pass d to the helper function
    //not sure how to do that yet
    //update: maybe use an extra loop to manually copy
    //public uint64 d_len = T_n - T_p_ptr;
    //public mut uint64[d_len] d = arrzeros(d_len);
    //_partial64_copy(T_p, ref d, T_p_ptr);
    _mpi_mul_hlp(m, B_p, ref arrview(T_p, T_p_ptr, T_n - T_p_ptr), u0);
    _mpi_mul_hlp(n, N_p, ref arrview(T_p, T_p_ptr, T_n - T_p_ptr), u1);

    T_p[T_p_ptr] = u0;
    T_p_ptr += 1;
    T_p[T_p_ptr + n + 1] = 0;
  }

    //XXX not sure how to handle d here, manually copy for now
    //public uint64 d_len = T_n - T_p_ptr;
    //public mut uint64[d_len] d = arrzeros(d_len);
    //_partial64_copy(T_p, ref d, T_p_ptr);
    //XXX how to copy n+1 * ciL bytes from d to A_p
    //what is the size of A_p, what is the size of d?
    
    public uint64 ciL = 8;
    for(uint64 i = 0 to (n+1) * ciL) {
      A_p[i] = d[i];
    }

    if(_mbedtls_mpi_cmp_abs(A_s, A_n, A_p, N_s, N_n, N_p) >= 0) {
      _mpi_sub_hlp(n, ref N_p, ref A_p);
    } else {
      _mpi_sub_hlp(n, ref A_p, ref T_p);
    }

    return 0;
}



