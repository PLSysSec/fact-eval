/*
  mbedtls/include/bignum.h
  typedef  int64_t mbedtls_mpi_sint;
  typedef uint64_t mbedtls_mpi_uint;
*/

/*
  mbedtls/include/bignum.h:180
  struct mbedtls_mpi
    int s
    size_t n
    mbedtls_mpi_uint *p     //how should we handle the pointer here?
                            //it looks like a pointer to an array
*/


void _mpi_mul_hlp(
    public uint64 n,
    secret uint64[] s,
    secret mut uint64[] d,
    secret uint64 b) {
  secret mut uint64 c = 0;

  for (uint64 i = 0; i < n; i += 1) {
    secret uint128 r = s[i] * ((uint128)b);
    secret mut uint64 r0 = (uint64)r;
    secret mut uint64 r1 = (uint64)(r >> 64);
    r0 += c;
    r1 += r0 < c ? 1 : 0;
    r0 += d[i];
    r1 += r0 < d[i] ? 1 : 0;
    c = r1;
    d[i] = r0;
  }

  for (uint64 i = n; i < len d; i += 1) {
    d[i] += c;
    c = d[i] < c ? 1 : 0;
  }
}

secret int32 _mbedtls_mpi_cmp_abs(
    secret int32 X_s,
    secret uint64[] X_p,
    secret int32 Y_s,
    secret uint64[] Y_p) {
  secret mut uint64 saved_i = 0;
  secret mut uint64 saved_j = 0;

  for (uint64 i = len X_p; i > 0; i -= 1) {
    if (saved_i == 0 && X_p[i - 1] != 0) {
      saved_i = i;
    }
  }

  for (uint64 j = len Y_p; j > 0; j -= 1) {
    if (saved_j == 0 && Y_p[j - 1] != 0) {
      saved_j = j;
    }
  }

  if (saved_i == 0 && saved_j == 0) {
    return 0;
  }

  if (saved_i > saved_j) {
    return 1;
  }
  if (saved_j > saved_i) {
    return -1;
  }

  for (uint64 i = len X_p; i > 0; i -= 1) {
    if (i <= saved_i) {
      if (X_p[i - 1] > Y_p[i - 1]) {
        return 1;
      }
      if (X_p[i - 1] < Y_p[i - 1]) {
        return -1;
      }
    }
  }

  return 0;
}

void _mpi_sub_hlp(
    public uint64 n,
    secret uint64[] s,
    secret mut uint64[] d) {
  secret mut uint64 c = 0;
  secret mut uint64 z = 0;

  for (uint64 i = 0; i < n; i += 1) {
    z = d[i] < c ? 1 : 0;
    d[i] -= c;
    c = (d[i] < s[i] ? 1 : 0) + z;
    d[i] -= s[i];
  }

  for (uint64 i = n; i < len d; i += 1) {
    z = (d[i] < c ? 1 : 0);
    d[i] -= c;
    c = z;
  }
}

/* mbedtls/library/bignum.c:1559 */
export
public int32 _mpi_montmul(
  //mbedtls_mpi *A
  secret int32 A_s,
  secret mut uint64[] A_p,
  //const mbedtls_mpi *B
  //secret int32 B_s,
  secret uint64[] B_p,
  //const mbedtls_mpi *N
  secret int32 N_s,
  secret mut uint64[] N_p,
  secret uint64 mm,
  //const mbedtls_mpi *T
  secret int32 T_s,
  secret mut uint64[] T_p) {

  /* do the NULL check in the c wrapper */

  public uint64 n = len N_p;
  public uint64 m = (len B_p < n) ? len B_p : n;

  for(uint64 i = 0; i < n; i += 1) {
    secret uint64 u0 = A_p[i];
    secret uint64 u1 = (T_p[i] + (u0 * B_p[0])) * mm;

    _mpi_mul_hlp(m, B_p, ref arrview(T_p, i, (len T_p) - i), u0);
    _mpi_mul_hlp(n, N_p, ref arrview(T_p, i, (len T_p) - i), u1);

    T_p[i] = u0;
    T_p[i + 1 + n + 1] = 0;
  }

  for(uint64 i = 0; i <= n; i += 1) {
    A_p[i] = T_p[n + i];
  }

  if(_mbedtls_mpi_cmp_abs(A_s, A_p, N_s, N_p) >= 0) {
    _mpi_sub_hlp(n, N_p, ref A_p);
  }

  return 0;
}
