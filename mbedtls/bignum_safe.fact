//typedef struct
//{
//    int s;              /*!<  integer sign      */
//    size_t n;           /*!<  total # of limbs  */
//    mbedtls_mpi_uint *p;          /*!<  pointer to limbs  */
//}
//mbedtls_mpi;

struct mbedtls_mpi {
    secret mut int32 s;
    public mut uint64 n; //it's ok to leak the size
    secret mut uint64[n] p;
}
/* right now handle mbedtls_mpi_grow() in c wrapper */
secret mpi_safe_cond_assign(
    mut struct mbedtls_mpi X,
    struct mbedtls_mpi Y,
    secret uint8 assign){
    
    X.s = assign == 1 ? Y.s : X.s;
    for(uint64 i = 0 to Y.n) {
        X.p[i] = assign == 1 ? Y.p[i] : X.p[i];
    }
}


/*
 * Conditionally assign X = Y, without leaking information
 * about whether the assignment was made or not.
 * (Leaking information about the respective sizes of X and Y is ok however.)
 */
//int mbedtls_mpi_safe_cond_assign( mbedtls_mpi *X, const mbedtls_mpi *Y, unsigned char assign )
//{
//    int ret = 0;
//    size_t i;
//
//    /* make sure assign is 0 or 1 in a time-constant manner */
//    assign = (assign | (unsigned char)-assign) >> 7;
//
//    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
//
//    X->s = X->s * ( 1 - assign ) + Y->s * assign;
//
//    for( i = 0; i < Y->n; i++ )
//        X->p[i] = X->p[i] * ( 1 - assign ) + Y->p[i] * assign;
//
//    for( ; i < X->n; i++ )
//        X->p[i] *= ( 1 - assign );
//
//cleanup:
//    return( ret );
//}


/*
 * Enlarge to the specified number of limbs
 */
//int mbedtls_mpi_grow( mbedtls_mpi *X, size_t nblimbs )
//{
//    mbedtls_mpi_uint *p;
//
//    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
//        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
//
//    if( X->n < nblimbs )
//    {
//        if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
//            return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
//
//        if( X->p != NULL )
//        {
//            memcpy( p, X->p, X->n * ciL );
//            mbedtls_mpi_zeroize( X->p, X->n );
//            mbedtls_free( X->p );
//        }
//
//        X->n = nblimbs;
//        X->p = p;
//    }
//
//    return( 0 );
//}
