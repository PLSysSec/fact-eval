diff --git a/ssl/__s3_cbc.c b/ssl/__s3_cbc.c
new file mode 100644
index 0000000..c0d6521
--- /dev/null
+++ b/ssl/__s3_cbc.c
@@ -0,0 +1,81 @@
+#include "internal/constant_time_locl.h"
+#include "ssl_locl.h"
+#include "internal/cryptlib.h"
+
+#include <openssl/md5.h>
+#include <openssl/sha.h>
+            void _md_transform(int ctx_type, void* ctx, const unsigned char *block) {
+              switch (ctx_type) {
+    case NID_sha1:
+      //printf("md sha1\n");
+              SHA1_Transform(ctx, block);
+              break;
+    case NID_sha256:
+      //printf("md sha256\n");
+              SHA256_Transform(ctx, block);
+              break;
+    case NID_sha384:
+      //printf("md sha384\n");
+              SHA512_Transform(ctx, block);
+              break;
+    default:
+              ((char*)ctx)[88888888888888] = 4;
+              break;
+              }
+            }
+static void tls1_sha1_final_raw(void *ctx, unsigned char *md_out)
+{
+    SHA_CTX *sha1 = ctx;
+    l2n(sha1->h0, md_out);
+    l2n(sha1->h1, md_out);
+    l2n(sha1->h2, md_out);
+    l2n(sha1->h3, md_out);
+    l2n(sha1->h4, md_out);
+}
+static void tls1_sha256_final_raw(void *ctx, unsigned char *md_out)
+{
+    SHA256_CTX *sha256 = ctx;
+    unsigned i;
+
+    for (i = 0; i < 8; i++) {
+        l2n(sha256->h[i], md_out);
+    }
+}
+static void tls1_sha512_final_raw(void *ctx, unsigned char *md_out)
+{
+    SHA512_CTX *sha512 = ctx;
+    unsigned i;
+
+    for (i = 0; i < 8; i++) {
+        l2n8(sha512->h[i], md_out);
+    }
+}
+        void _md_final_raw(int ctx_type, void* ctx, unsigned char *md_out) {
+          switch (ctx_type) {
+    case NID_sha1:
+          tls1_sha1_final_raw(ctx, md_out);
+          break;
+    case NID_sha256:
+          tls1_sha256_final_raw(ctx, md_out);
+          break;
+    case NID_sha384:
+          tls1_sha512_final_raw(ctx, md_out);
+          break;
+    default:
+              ((char*)ctx)[88888888888888] = 4;
+              break;
+          }
+        }
+
+void _print(uint64_t n) {
+  //printf("_print: %lu\n", n);
+}
+void _prints(uint64_t n) {
+  //printf("%lu ", n);
+}
+void _println() {
+  //printf("\n");
+}
+void _printx(uint8_t b) {
+  //printf("%02x ", b);
+}
diff --git a/ssl/build.info b/ssl/build.info
index bb2f1de..f9de1ff 100644
--- a/ssl/build.info
+++ b/ssl/build.info
@@ -3,7 +3,7 @@ SOURCE[../libssl]=\
         pqueue.c packet.c \
         statem/statem_srvr.c statem/statem_clnt.c  s3_lib.c  s3_enc.c record/rec_layer_s3.c \
         statem/statem_lib.c statem/extensions.c statem/extensions_srvr.c \
-        statem/extensions_clnt.c statem/extensions_cust.c s3_cbc.c s3_msg.c \
+        statem/extensions_clnt.c statem/extensions_cust.c s3_cbc.c __s3_cbc.c _s3_cbc.s s3_msg.c \
         methods.c   t1_lib.c  t1_enc.c tls13_enc.c \
         d1_lib.c  record/rec_layer_d1.c d1_msg.c \
         statem/statem_dtls.c d1_srtp.c \
diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c
index 7d9c377..05bda05 100644
--- a/ssl/s3_cbc.c
+++ b/ssl/s3_cbc.c
@@ -125,6 +125,26 @@ char ssl3_cbc_record_digest_supported(const EVP_MD_CTX *ctx)
  * padding too. )
  * Returns 1 on success or 0 on error
  */
+void __ssl3_cbc_digest_record(
+  /*secret*/ uint8_t md_state[216],
+  /*secret*/ uint8_t mac_out[64],
+  /*secret*/ uint8_t hmac_pad[128],
+  /*public*/ uint64_t md_size,
+  /*public*/ uint64_t md_block_size,
+  /*public*/ uint64_t log_md_block_size,
+  /*public*/ uint64_t sslv3_pad_length,
+  /*public*/ uint64_t md_length_size,
+  /*public*/ uint8_t length_is_big_endian,
+  /*public*/ int32_t sha_type,
+  /*secret*/ const uint8_t header[13],
+  /*secret*/ const uint8_t data[],
+  /*public*/ uint32_t __data_len,
+  /*secret*/ uint64_t data_plus_mac_size,
+  /*secret*/ const uint8_t mac_secret[],
+  /*public*/ uint32_t __mac_secret_len,
+  /*public*/ uint8_t is_sslv3);
+void _md_transform(int ctx_type, void* ctx, const unsigned char *block);
+void _md_final_raw(int ctx_type, void* ctx, unsigned char *md_out);
 int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
                            unsigned char *md_out,
                            size_t *md_out_size,
@@ -141,7 +161,7 @@ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
     } md_state;
     void (*md_final_raw) (void *ctx, unsigned char *md_out);
     void (*md_transform) (void *ctx, const unsigned char *block);
-    size_t md_size, md_block_size = 64;
+    size_t md_size, md_block_size = 64, log_md_block_size = 6;
     size_t sslv3_pad_length = 40, header_length, variance_blocks,
         len, max_mac_bytes, num_blocks,
         num_starting_blocks, k, mac_end_offset, c, index_a, index_b;
@@ -169,6 +189,7 @@ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
     if (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))
         return 0;
 
+    int sha_type = EVP_MD_CTX_type(ctx);
     switch (EVP_MD_CTX_type(ctx)) {
     case NID_md5:
         if (MD5_Init((MD5_CTX *)md_state.c) <= 0)
@@ -212,6 +233,7 @@ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
             (void (*)(void *ctx, const unsigned char *block))SHA512_Transform;
         md_size = 384 / 8;
         md_block_size = 128;
+        log_md_block_size = 7;
         md_length_size = 16;
         break;
     case NID_sha512:
@@ -222,6 +244,7 @@ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
             (void (*)(void *ctx, const unsigned char *block))SHA512_Transform;
         md_size = 64;
         md_block_size = 128;
+        log_md_block_size = 7;
         md_length_size = 16;
         break;
     default:
@@ -239,217 +262,30 @@ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,
             || !ossl_assert(md_size <= EVP_MAX_MD_SIZE))
         return 0;
 
-    header_length = 13;
-    if (is_sslv3) {
-        header_length = mac_secret_length + sslv3_pad_length + 8 /* sequence
-                                                                  * number */  +
-            1 /* record type */  +
-            2 /* record length */ ;
-    }
-
-    /*
-     * variance_blocks is the number of blocks of the hash that we have to
-     * calculate in constant time because they could be altered by the
-     * padding value. In SSLv3, the padding must be minimal so the end of
-     * the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively
-     * assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes
-     * of hash termination (0x80 + 64-bit length) don't fit in the final
-     * block, we say that the final two blocks can vary based on the padding.
-     * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not
-     * required to be minimal. Therefore we say that the final six blocks can
-     * vary based on the padding. Later in the function, if the message is
-     * short and there obviously cannot be this many blocks then
-     * variance_blocks can be reduced.
-     */
-    variance_blocks = is_sslv3 ? 2 : 6;
-    /*
-     * From now on we're dealing with the MAC, which conceptually has 13
-     * bytes of `header' before the start of the data (TLS) or 71/75 bytes
-     * (SSLv3)
-     */
-    len = data_plus_mac_plus_padding_size + header_length;
-    /*
-     * max_mac_bytes contains the maximum bytes of bytes in the MAC,
-     * including * |header|, assuming that there's no padding.
-     */
-    max_mac_bytes = len - md_size - 1;
-    /* num_blocks is the maximum number of hash blocks. */
-    num_blocks =
-        (max_mac_bytes + 1 + md_length_size + md_block_size -
-         1) / md_block_size;
-    /*
-     * In order to calculate the MAC in constant time we have to handle the
-     * final blocks specially because the padding value could cause the end
-     * to appear somewhere in the final |variance_blocks| blocks and we can't
-     * leak where. However, |num_starting_blocks| worth of data can be hashed
-     * right away because no padding value can affect whether they are
-     * plaintext.
-     */
-    num_starting_blocks = 0;
-    /*
-     * k is the starting byte offset into the conceptual header||data where
-     * we start processing.
-     */
-    k = 0;
-    /*
-     * mac_end_offset is the index just past the end of the data to be MACed.
-     */
-    mac_end_offset = data_plus_mac_size + header_length - md_size;
-    /*
-     * c is the index of the 0x80 byte in the final hash block that contains
-     * application data.
-     */
-    c = mac_end_offset % md_block_size;
-    /*
-     * index_a is the hash block number that contains the 0x80 terminating
-     * value.
-     */
-    index_a = mac_end_offset / md_block_size;
-    /*
-     * index_b is the hash block number that contains the 64-bit hash length,
-     * in bits.
-     */
-    index_b = (mac_end_offset + md_length_size) / md_block_size;
-    /*
-     * bits is the hash-length in bits. It includes the additional hash block
-     * for the masked HMAC key, or whole of |header| in the case of SSLv3.
-     */
-
-    /*
-     * For SSLv3, if we're going to have any starting blocks then we need at
-     * least two because the header is larger than a single block.
-     */
-    if (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {
-        num_starting_blocks = num_blocks - variance_blocks;
-        k = md_block_size * num_starting_blocks;
-    }
-
-    bits = 8 * mac_end_offset;
-    if (!is_sslv3) {
-        /*
-         * Compute the initial HMAC block. For SSLv3, the padding and secret
-         * bytes are included in |header| because they take more than a
-         * single block.
-         */
-        bits += 8 * md_block_size;
-        memset(hmac_pad, 0, md_block_size);
-        if (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))
-            return 0;
-        memcpy(hmac_pad, mac_secret, mac_secret_length);
-        for (i = 0; i < md_block_size; i++)
-            hmac_pad[i] ^= 0x36;
-
-        md_transform(md_state.c, hmac_pad);
-    }
-
-    if (length_is_big_endian) {
-        memset(length_bytes, 0, md_length_size - 4);
-        length_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);
-        length_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);
-        length_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);
-        length_bytes[md_length_size - 1] = (unsigned char)bits;
-    } else {
-        memset(length_bytes, 0, md_length_size);
-        length_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);
-        length_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);
-        length_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);
-        length_bytes[md_length_size - 8] = (unsigned char)bits;
-    }
-
-    if (k > 0) {
-        if (is_sslv3) {
-            size_t overhang;
-
-            /*
-             * The SSLv3 header is larger than a single block. overhang is
-             * the number of bytes beyond a single block that the header
-             * consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no
-             * ciphersuites in SSLv3 that are not SHA1 or MD5 based and
-             * therefore we can be confident that the header_length will be
-             * greater than |md_block_size|. However we add a sanity check just
-             * in case
-             */
-            if (header_length <= md_block_size) {
-                /* Should never happen */
-                return 0;
-            }
-            overhang = header_length - md_block_size;
-            md_transform(md_state.c, header);
-            memcpy(first_block, header + md_block_size, overhang);
-            memcpy(first_block + overhang, data, md_block_size - overhang);
-            md_transform(md_state.c, first_block);
-            for (i = 1; i < k / md_block_size - 1; i++)
-                md_transform(md_state.c, data + md_block_size * i - overhang);
-        } else {
-            /* k is a multiple of md_block_size. */
-            memcpy(first_block, header, 13);
-            memcpy(first_block + 13, data, md_block_size - 13);
-            md_transform(md_state.c, first_block);
-            for (i = 1; i < k / md_block_size; i++)
-                md_transform(md_state.c, data + md_block_size * i - 13);
-        }
-    }
-
     memset(mac_out, 0, sizeof(mac_out));
-
-    /*
-     * We now process the final hash blocks. For each block, we construct it
-     * in constant time. If the |i==index_a| then we'll include the 0x80
-     * bytes and zero pad etc. For each block we selectively copy it, in
-     * constant time, to |mac_out|.
-     */
-    for (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;
-         i++) {
-        unsigned char block[MAX_HASH_BLOCK_SIZE];
-        unsigned char is_block_a = constant_time_eq_8_s(i, index_a);
-        unsigned char is_block_b = constant_time_eq_8_s(i, index_b);
-        for (j = 0; j < md_block_size; j++) {
-            unsigned char b = 0, is_past_c, is_past_cp1;
-            if (k < header_length)
-                b = header[k];
-            else if (k < data_plus_mac_plus_padding_size + header_length)
-                b = data[k - header_length];
-            k++;
-
-            is_past_c = is_block_a & constant_time_ge_8_s(j, c);
-            is_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);
-            /*
-             * If this is the block containing the end of the application
-             * data, and we are at the offset for the 0x80 value, then
-             * overwrite b with 0x80.
-             */
-            b = constant_time_select_8(is_past_c, 0x80, b);
-            /*
-             * If this block contains the end of the application data
-             * and we're past the 0x80 value then just write zero.
-             */
-            b = b & ~is_past_cp1;
-            /*
-             * If this is index_b (the final block), but not index_a (the end
-             * of the data), then the 64-bit length didn't fit into index_a
-             * and we're having to add an extra block of zeros.
-             */
-            b &= ~is_block_b | is_block_a;
-
-            /*
-             * The final bytes of one of the blocks contains the length.
-             */
-            if (j >= md_block_size - md_length_size) {
-                /* If this is index_b, write a length byte. */
-                b = constant_time_select_8(is_block_b,
-                                           length_bytes[j -
-                                                        (md_block_size -
-                                                         md_length_size)], b);
-            }
-            block[j] = b;
-        }
-
-        md_transform(md_state.c, block);
-        md_final_raw(md_state.c, block);
-        /* If this is index_b, copy the hash value to |mac_out|. */
-        for (j = 0; j < md_size; j++)
-            mac_out[j] |= block[j] & is_block_b;
-    }
+    memset(hmac_pad, 0, md_block_size);
+
+    __ssl3_cbc_digest_record(
+        // outputs
+            md_state.c,
+            mac_out,
+            hmac_pad,
+        // parameters
+            md_size,
+            md_block_size,
+            log_md_block_size,
+            sslv3_pad_length,
+            md_length_size,
+            length_is_big_endian,
+            sha_type,
+        // inputs
+            header,
+            data,
+            data_plus_mac_plus_padding_size,
+            data_plus_mac_size,
+            mac_secret,
+            mac_secret_length,
+            is_sslv3);
 
     md_ctx = EVP_MD_CTX_new();
     if (md_ctx == NULL)
