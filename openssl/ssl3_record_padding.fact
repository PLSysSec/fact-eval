/*
openssl/ssl/record/record.h
typedef struct ssl3_record_st {
    int rec_version;
    int type;
    size_t length;
    size_t orig_len;
    size_t off;
    usigned char *data;
    unsigned char *input;
    unsigned char *comp;
    unsigned int read;
    unsigned long epoch;
    unsigned char seq_num[SEQ_NUM_SIZE]
} SSL3_RECORD
*/

// this port version is a semi-direct translate
// public value assigned to secret value
secret int32 ssl3_cbc_remove_padding( 
    // SSL3_RECORD struct
    public int16 rec_version,
    public int16 rec_type,
    secret mut uint32 rec_length,
    secret uint32 rec_orig_len,
    secret uint8[] rec_data,
    secret uint8[] rec_input,
    secret uint8[] rec_comp,
    public uint16 rec_read,
    public uint32 rec_epoch,
    public uint8[8] seq_num,

    // public rec->length
    public uint32 length,

    public uint32 block_size,
    public uint32 mac_size) {

    secret mut uint32 padding_length = 0;
    secret mut uint32 good = 0;
    public uint32 overhead = 1 + mac_size;
    secret mut int32 ret = 0;

    // test public lengths in non-constant time
    if(overhead > length) {
        return ret;
    }

    padding_length = rec_data[length - 1];
    good = (length < (padding_length + overhead)) || (block_size < padding_length + 1) ? 0 : 0xFFFFFFFF;
    rec_length -= good & (padding_length + 1);
    ret = (good == 0) ? -1 : 1;
    return ret;
}


// this is a simplified version 
secret int32 ssl3_cbc_remove_padding_simple( 
    // SSL3_RECORD struct
    secret mut uint32 rec_length,
    secret uint8[] rec_data,
    public uint32 length,   // public rec->length
    public uint32 block_size,
    public uint32 mac_size) {
    
    secret mut uint32 padding_length = 0;
    public uint32 overhead = 1 + mac_size;
    secret mut int32 ret = 0;

    if(overhead > length) {
        return ret;
    }

    padding_length = rec_data[length - 1];
    if(length >= (padding_length + overhead) && (block_size >= padding_length + 1)) {
        rec_length -= padding_length + 1;
        ret = 1;
    } else {
        ret = -1;
    }

    return ret;
}

/*
    crypto/evp/evp_lib.c line 196`
    unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher)
 */

/*
    crypto/evp/evp_lib.c
    const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx)
 */

/*
    struct evp_cipher_ctx_st defined in openssl/crypto/evp/evp_locl.h
 */

/*
 *  openssl/crypto/include/internal/evp_int.h
 *  struct evp_cipher_st
 */

/*
    SSL struct(ssl/ssl_local.h line978) contains 
    SSL_METHOD struct (ssl/ssl_local.h line 450)
    SSL_METHOD contains struct ssl3_enc_method (ssl/ssl_local.h line 1741)
 */

secret int32 tls1_cbc_remove_padding(
    /* 
        struct SSL, but we only need some flags
        s->ssl_method->ssl_enc->enc_flags (uint32_t enc_flags)
     */
    public uint32 s_enc_flags,
    public uint64 s_evp_cipher_flags,
    // struct SSL3_RECORD
    secret mut uint32 rec_length,
    public mut uint32 rec_orig_len,         // what is orig_len? should it be public?
    secret uint8[] rec_data,
    public mut uint32 length,    // this padded record length is public
    public uint32 block_size,
    public uint32 mac_size) {

    public uint32 EVP_CIPH_FLAG_AEAD_CIPHER = 0x200000;
    public uint32 SSL_ENC_FLAG_EXPLICIT_IV = 0x1;

    secret mut uint32 good = 0;
    secret mut uint8 padding_length = 0;
    public uint32 overhead = 1 + mac_size;

    public mut uint32 data_ptr = 0;
    public mut uint32 input_ptr = 0;

    secret mut int32 ret = 0;

    if((s_enc_flags & SSL_ENC_FLAG_EXPLICIT_IV) != 0) {
        if(overhead + block_size > length) {
            return ret;
        }
        // skip explicit IV
        // data is a pointer
        data_ptr += block_size;     
        input_ptr += block_size;
        rec_length -= block_size;
        // not sure how to handle the following line
        rec_orig_len -= block_size;

        length -= block_size;
    } else if(overhead > length) {
        return 0;
    }

    padding_length = rec_data[data_ptr + length - 1];

    if((s_evp_cipher_flags & EVP_CIPH_FLAG_AEAD_CIPHER) != 0) {
        rec_length -= padding_length + 1;
        return 1;
    }

    good = rec_length >= overhead + padding_length ? 0xFFFFFFFF : 0;

    public mut uint32 to_check = 256;
    if(to_check > length) {
        to_check = length;
    }

    for(uint32 i = 0 to to_check) {
        secret uint8 mask = padding_length > i ? 0xFF : 0x00;
        secret uint8 b = rec_data[data_ptr + length - 1 - i];
        good &= ~((uint32)mask & (padding_length & (uint32)b)); 
    }

    good = (uint8)good == 0xff ? 0xFFFFFFFF : 0;
    rec_length -= good & (padding_length + 1);
    ret = good == 0 ? -1 : 1;
    return ret;
}

/* simplified version */
secret int32 tls1_cbc_remove_padding_simple(
    /* 
        struct SSL, but we only need some flags
        s->ssl_method->ssl_enc->enc_flags (uint32_t enc_flags)
     */
    public uint32 s_enc_flags,
    public uint64 s_evp_cipher_flags,
    // struct SSL3_RECORD
    secret mut uint32 rec_length,
    public mut uint32 rec_orig_len,         // what is orig_len? should it be public?
    secret uint8[] rec_data,
    public mut uint32 length,    // this padded record length is public
    public uint32 block_size,
    public uint32 mac_size) {

    public uint32 EVP_CIPH_FLAG_AEAD_CIPHER = 0x200000;
    public uint32 SSL_ENC_FLAG_EXPLICIT_IV = 0x1;

    secret mut uint32 good = 0;
    secret mut uint8 padding_length = 0;
    public uint32 overhead = 1 + mac_size;

    public mut uint32 data_ptr = 0;
    public mut uint32 input_ptr = 0;

    secret mut int32 ret = 0;

    if((s_enc_flags & SSL_ENC_FLAG_EXPLICIT_IV) != 0) {
        if(overhead + block_size > length) {
            return ret;
        }
        // skip explicit IV
        // data is a pointer
        data_ptr += block_size;     
        input_ptr += block_size;
        rec_length -= block_size;
        // not sure how to handle the following line
        rec_orig_len -= block_size;

        length -= block_size;
    } else if(overhead > length) {
        return 0;
    }

    padding_length = rec_data[data_ptr + length - 1];

    if((s_evp_cipher_flags & EVP_CIPH_FLAG_AEAD_CIPHER) != 0) {
        rec_length -= padding_length + 1;
        return 1;
    }

    good = rec_length >= overhead + padding_length ? 0xFFFFFFFF : 0;

    public mut uint32 to_check = 256;
    if(to_check > length) {
        to_check = length;
    }

    for(uint32 i = 0 to to_check) {
      if(i < padding_length) {
        secret uint8 b = rec_data[data_ptr + length - 1 - i];
        if(b != (uint8)padding_length) {
          good = 0;
        }
      }
    }

    rec_length -= good & (padding_length + 1);
    ret = good == 0 ? -1 : 1;
    return ret;
}
